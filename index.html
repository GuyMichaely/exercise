<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Beep Phases</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: sans-serif;
      background: #111;
      color: #eee;
    }
    .container {
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      gap: 1rem;
    }
    #phase {
      font-size: 2rem;
      font-weight: bold;
    }
    #info {
      font-size: 0.95rem;
      opacity: 0.8;
      max-width: 600px;
    }
    #startButton {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="phase">Waiting for user interaction…</div>
    <div id="info">
      Click or tap anywhere (or the button) to enable audio and start.<br>
      Phase 1: 10× [on beep, 5s, off beep, 5s]<br>
      Phase 2: 2× [two quick on beeps, wait for click/tap, 45s]<br>
      Phase 3: 10× [on beep, 10s, off beep, 10s]
    </div>
    <button id="startButton">Start</button>
  </div>

    <script>
    const ON_FREQ = 523.25;   // one octave above middle C (C5)
    const OFF_FREQ = 261.63;  // middle C (C4)
    const BEEP_DURATION = 0.2; // seconds (~200 ms)

    // High-level routine configuration (seconds)
    const timings = {
      phase1: {
        sets: 1,
        reps: 10,
        on: 5,
        off: 5,
      },
      phase2: {
        sets: 2,
        postClickWait: 45,
      },
      phase3: {
        sets: 1,
        reps: 10,
        on: 10,
        off: 10,
      },
    };

    // Rest between sets for phases 1 and 3 (seconds)
    const SET_REST_SECONDS = 60;

    // Global time scaling factor (set to 1 for real timings, < 1 for faster testing)
    const TIME_SCALE = 1; // e.g., 0.1 means 5s -> 0.5s

    let audioCtx = null;
    let started = false;

    const phaseEl = document.getElementById('phase');
    const startButton = document.getElementById('startButton');

    function setPhaseText(text) {
      phaseEl.textContent = text;
    }

    function setPhaseStatus(phaseName, currentSet, totalSets, extra = '') {
      let base = `${phaseName} – Set ${currentSet}/${totalSets}`;
      if (extra) base += ` – ${extra}`;
      setPhaseText(base);
    }

    // Create and resume AudioContext strictly inside user gesture
    function unlockAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') {
        try {
          audioCtx.resume();
        } catch (e) {
          console.error('AudioContext resume failed:', e);
        }
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function toMs(seconds) {
      return seconds * 1000 * TIME_SCALE;
    }

    // Wait that can be fast-forwarded by a click/tap anywhere on the page
    function waitWithSkip(seconds) {
      const ms = toMs(seconds);
      return new Promise(resolve => {
        const handler = () => {
          cleanup();
          resolve();
        };
        const timeoutId = setTimeout(() => {
          cleanup();
          resolve();
        }, ms);
        function cleanup() {
          clearTimeout(timeoutId);
          document.removeEventListener('click', handler);
          document.removeEventListener('touchstart', handler);
        }
        document.addEventListener('click', handler);
        document.addEventListener('touchstart', handler);
      });
    }

    // Base beep: smooth sine tone
    function beep(freq, duration = BEEP_DURATION) {
      return internalBeep(freq, duration, 'sine');
    }

    // Phase-2 special: slightly sharper, still not too harsh (triangle)
    function beepSquare(freq, duration = BEEP_DURATION) {
      return internalBeep(freq, duration, 'triangle');
    }

    function internalBeep(freq, duration, waveType) {
      if (!audioCtx) {
        console.warn('AudioContext not unlocked yet');
        return Promise.resolve();
      }

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = waveType; // use waveType
      osc.frequency.value = freq;

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;

      // quick fade in/out to avoid clicks; slightly louder
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.8, now + 0.01);
      gain.gain.linearRampToValueAtTime(0.0, now + duration);

      osc.start(now);
      osc.stop(now + duration + 0.05);

      return new Promise(resolve => {
        osc.onended = resolve;
      });
    }

    function waitForClickOrTap() {
      return new Promise(resolve => {
        const handler = () => {
          document.removeEventListener('click', handler);
          document.removeEventListener('touchstart', handler);
          resolve();
        };
        document.addEventListener('click', handler);
        document.addEventListener('touchstart', handler);
      });
    }

    async function runPhase1() {
      const { sets, reps, on, off } = timings.phase1;
      for (let s = 1; s <= sets; s++) {
        for (let r = 1; r <= reps; r++) {
          setPhaseStatus('Phase 1', s, sets, `Rep ${r}/${reps} (on)`);
          await beep(ON_FREQ);
          await waitWithSkip(on);

          setPhaseStatus('Phase 1', s, sets, `Rep ${r}/${reps} (off)`);
          await beep(OFF_FREQ);
          await waitWithSkip(off);
        }
        if (s < sets) {
          setPhaseStatus('Phase 1', s, sets, `Resting ${SET_REST_SECONDS}s between sets`);
          await waitWithSkip(SET_REST_SECONDS);
        }
      }
    }

    async function runPhase2() {
      const { sets, postClickWait } = timings.phase2;
      for (let s = 1; s <= sets; s++) {
        setPhaseStatus('Phase 2', s, sets, 'Beeps');
        await beepSquare(ON_FREQ, 0.12); // shorter, slightly sharper
        await sleep(toMs(0.005));        // very small gap, not worth skipping
        await beepSquare(ON_FREQ, 0.12);

        setPhaseStatus('Phase 2', s, sets, 'Waiting for click/tap');
        await waitForClickOrTap();

        setPhaseStatus('Phase 2', s, sets, `Waiting ${postClickWait}s`);
        await waitWithSkip(postClickWait);
      }
    }

    async function playCMajorScale() {
      // C major scale from middle C up one octave
      const freqs = [
        261.63, // C4
        293.66, // D4
        329.63, // E4
        349.23, // F4
        392.0,  // G4
        440.0,  // A4
        493.88, // B4
        523.25, // C5
      ];
      for (const f of freqs) {
        await beep(f, 0.135);
        // await sleep(toMs(0.05));
      }
    }

    async function runPhase3() {
      const { sets, reps, on, off } = timings.phase3;
      for (let s = 1; s <= sets; s++) {
        for (let r = 1; r <= reps; r++) {
          setPhaseStatus('Phase 3', s, sets, `Rep ${r}/${reps} (on)`);
          await beep(ON_FREQ);
          await waitWithSkip(on);

          const isLastRep = (s === sets && r === reps);
          if (isLastRep) {
            setPhaseStatus('Phase 3', s, sets, `Final rep – C major scale`);
            await playCMajorScale();
          } else {
            setPhaseStatus('Phase 3', s, sets, `Rep ${r}/${reps} (off)`);
            await beep(OFF_FREQ);
            await waitWithSkip(off);
          }
        }
        if (s < sets) {
          setPhaseStatus('Phase 3', s, sets, `Resting ${SET_REST_SECONDS}s between sets`);
          await waitWithSkip(SET_REST_SECONDS);
        }
      }
    }

    async function runPhases() {
      await runPhase1();
      await runPhase2();
      await runPhase3();
      setPhaseText('Done');
    }

    function startSequence() {
      if (started) return;
      started = true;
      unlockAudio(); // create + resume AudioContext in the same user gesture
      if (startButton) startButton.style.display = 'none';
      setPhaseText('Starting…');
      runPhases();
    }

    // Attach only real user interaction events directly to starter
    startButton.addEventListener('click', startSequence);
    startButton.addEventListener('touchend', startSequence);
  </script>
</body>
</html>
